function solution(cards1, cards2, goal) {
    for (const str of goal) {
        if (str === cards1[0]) {
            cards1.shift();
        } else if (str === cards2[0]) {
            cards2.shift();
        } else {
            return "No"
        }
    }

    return "Yes"
}

[코드 리뷰]
오늘 문제는 1시간을 풀었는데 해결하지 못하여...
정답을 보고 코드를 이해하고 내가 다시 입력해보았다.

내가 막혔던 부분은 한 번 사용한 카드는 다시 사용할 수 없어야 하면서
카드를 사용하지 않고 다음 카드로 넘어갈 수 없다는 제약조건을 동시에 충족시키기 어려웠다.

위 작성된 코드를 보면 for of문을 통해 goal의 요소를 순회하면서 cards1과 cards2의 같은 요소가 있는지 찾아본다.
단, 카드를 사용하지 않고 다음 카드로 넘어갈 수 없기 때문에 0번째 요소만 비교해준다
0번째 요소만 비교할 수 있는 이유는 배열의 메서드 중 shift()메서드는 첫번째 요소를 삭제해주는 역할을 한다
즉, 한번 사용한 카드는 다시 사용할 수 없게 지우기 때문에 위 2개 조건을 모두 충족할 수 있는 식이 될 수 있다.
